/*************************************************************/
/*                                                           */
/* Copyright -                                               */
/*                                                           */
/*   THIS MODULE IS "RESTRICTED MATERIALS OF IBM"            */
/*   5654-030 (C) COPYRIGHT IBM CORP. - 1983, 1999           */
/*   LICENSED MATERIALS - PROPERTY OF IBM                    */
/*   ALL RIGHTS RESERVED.                                    */
/*                                                           */
/* Status - VM/ESA Version 2, Release 4.0                    */
/*************************************************************/
/*
   Support code - @V6GMAL1

   Format is:  EXECUPDT fn <ft   <fm   >> <(options...<)>>
                            EXEC  *

   Where:

   fn ft fm
         is the file identifier of the source input file.  The
         file must consist of card image records with length
         less than or equal to 255.  Record format must be
         Fixed.
         The last 8 columns of each card image must contain
         a sequence number.
         If the filetype or filemode are omitted,
         EXEC and * are assumed, respectively.

  Options:

     CTL cfn  specifies that "cfn CNTRL" is an update control
              file that controls the application of multiple
              update files to the source input file.

     NOUPdate specifies that no update files are to be
              applied to the source.  The HISTORY option
              will be ignored if this is specified.

     HISTory  specifies that the file 'cfn UPDATES' which is
              created by the UPDATE command is to be appended
              to the updated source as a comment.

     NOHISTory specifies that no history log is to be appended
              to the updated source.  This is the default.

     COMPress specifies that lines in the source that start
              with the characters '/*!' and start in column  */
              1 will be removed from the updated source to
              improve performance.  This is the default.

     NOCOMPress  specifies that no lines are to be deleted
              from the updated source.

     COMMents specifies that comments other than those removed
              by COMPRESS are not to be removed.

     NOCOMMents  specifies that all comments and leading
              blanks are to be removed.

     ETMODE   specifies that the exec contains DBCS characters
              and that pairing of DBCS SO and SI characters
              should be performed while quotes are being
              paired during the removal of comments.  This
              option only performs a function if NOCOMMENTS
              is specified.

     SID      specifies that the last 17 columns contain
              information to be removed from the source file.
              This must be in the format

                   n-16            n ( <= 255 )
                   |               |
                   V               V
                   SID_CODE SEQ_NUMB

     NOSID    specifies that only sequence numbers are to be
              removed from the updated source (the last 8
              columns).  This is the default.

      Other options as with the UPDATE command.

      Conflicting options may be specified with the last
      one specified taking precedence.

   This exec will create an executable EXEC file from a
   fixed source file with logical record length <= 255.
   This command invokes the UPDATE
   command to perform the update and can accept all of the
   normal update options.  In addition to the UPDATE options,
   it can be requested that SIDCODEs be removed from the EXEC,
   a log of the applied updates be included in the EXEC, and
   that specially tagged lines be removed to improve
   performance and readibility.                              */

  address command
  signal on novalue
  msgopt1 = '(CALLER WUP VAR ERRMSG'

/* First we parse the argument string into a fileid and any  */
/* options.                                                  */
  arg fn ft fm rest '(' opts ')'

/* Do we have an extra parameter?  If so, issue Error message*/
  If rest ¬= '' Then
     call ERRORS '24 649 rest' msgopt1 'FORMAT 02'

/* We must have a filename.  Issue Error message if none.    */
  If fn = '' Then
     call ERRORS '24 054' msgopt1 'FORMAT 01'

/* Now that we have checked the parameters, call the options */
/* routine to process the EXECUPDT options.  Anything unknown*/
/* is passed on to the UPDATE command.  The OUTMODE option   */
/* requires special processing since it is used by both.     */
/* Now, to establish some defaults.                          */

  cfn = ''                       /* Do not use CNTRL file    */
  history = 0                    /* Do not append update hist*/
  compress = 1                   /* Remove special comments  */
  comments = 1                   /* Keep normal comments     */
  etmode = 0                     /* No DBCS SO-SI pairing    */
  noupdate = 0                   /* Do apply updates         */
  trunc = 8                      /* Remove only sequence no. */
  updtopts = ''                  /* No update options        */
  otmode = 0                     /* No OUTMODE specified     */
  otfm = ''                      /* OUTMODE file mode        */
  If opts ¬='' Then call options /* If options, go process   */

  If ft = '' Then ft = 'EXEC'    /* No ft?  Then use default */
  If fm ¬= '' then fm = substr(fm,1,1)   /* Strip fm number  */
  Else fm = '*'                  /* No fm?  Default is *     */

     'MAKEBUF'                   /* Get new buffer for stack */
     'LISTFILE' fn '$'ft fm '(ALL FIFO' /* Get list of files */
     If rc = 28 then do          /* None found?              */
        ft = '$'||ft
        'DROPBUF'                /* Clean up the stack       */
        call ERRORS '28 002 fn ft fm',
              msgopt1 'FORMAT 09'
     end
/*   If any other error, then LISTFILE issued message.  Quit */
     Else if rc ¬= 0 then do
       realrc = rc
       'DROPBUF'
       exit realrc
     END /* else */

     pull . . fm . lrecl .       /* Get fm, lrecl            */
     'DROPBUF'                   /* And clean up the stack   */

/*           We issue a 'STATE' to check and see that the    */
/* file exists and to verify that a proper fileid (in        */
/* particular, the filemode) was given.                      */
      'CMDCALL STATE' fn '$'ft fm /* Use CMDCALL to get msg. */
      If rc ¬= 0 Then exit rc

/* Ok, we now have the filemode of the file to be processed, */
/* but if the file is on a read only disk, then we want to   */
/* place the updated file on the parent disk if the read only*/
/* disk is an extension.  If that disk is also read only,    */
/* then use the A disk.                                      */

    'MAKEBUF'                    /* Get a fresh stack again  */
    'QUERY DISK' left(fm,1) '(LIFO' /* Stack disk information*/
    If rc ¬=0 Then exit rc       /* Error, then exit         */
    pull 8 . diskmode diskstat .
    If diskstat = 'R/W' Then workfm = left(fm,1)

    Else do                      /* Ok, we need to check for */
                                 /* a parent disk.           */
       parse var diskmode '/' parent
       If parent ¬= '' Then do       /* have a parent disk?  */
         'QUERY DISK' parent '(LIFO' /* Stack disk info      */
         If rc ¬=0 Then exit rc      /* Error, then exit     */
          pull 8 . . diskstat .      /* Pull from the stack  */
          If diskstat = 'R/W'        /* Is it Read-Write?    */
             Then workfm = parent    /* yes, we can use it   */
             Else workfm = 'A'       /* No, use A disk       */
          end
       Else workfm = 'A'         /* No parent, so use 'A'    */
       end
    'DROPBUF'                    /* And drop our buffer again*/

/* At this point we have the actual filemode and the filemode*/
/* of a work disk, which is either the same as the filemode  */
/* of the file to be changed, the filemode of a parent disk, */
/* or is 'A'.  Now we issue the appropriate UPDATE command.  */

  updtrc = 0                     /* Set initial value        */
  If noupdate Then do
    sourcefm = left(fm,1)        /* Set up source filemode   */
    sourcefn = fn                /* Set up source filename   */
    end
  Else do
     sourcefm = workfm           /* Set up source filemode   */
     sourcefn = '$'fn            /* Set up source filename   */
     If cfn ¬= '' Then           /* CTL option - use cfn file*/
        'UPDATE' fn '$'ft fm cfn 'CNTRL * (CTL' updtopts ')'
     Else                        /* straight update          */
        'UPDATE' fn '$'ft fm '(' updtopts ')'
     updtrc = rc
/* If RC is non-zero & not 40 then UPDATE has issued an error*/
/* message so quit, otherwise we continue                    */
     If rc = 40 Then do
        sourcefn = fn                /* 40 means no updates  */
        sourcefm = fm                /* and use original fm  */
        end
     Else If rc ¬= 0 & rc ¬= 12 Then Exit rc
     end

/* OK, use XEDIT to convert the macro into an executable     */
/* version and to remove the special comments from the file. */
/* This is done via stacked commands to the editor.          */

/* Now do the actual business of making it run               */

  If otfm ¬= '' Then do              /* OUTMODE specified    */
   workfm = otfm                     /* use it               */
   if updtrc ¬= 40 & ¬noupdate then  /* UPDATE successful?   */
     sourcefm = left(otfm,1)         /* Change source fmode  */
   end
  workfm = left(workfm,1)'2'         /* set working filemode */
  'MAKEBUF'
  Queue 'COMMAND SET LINEND OFF'
  Queue 'COMMAND SET RECFM V'        /* Variable RECFM       */
  Queue 'COMMAND SET LRECL' lrecl - trunc /* set trunc       */
  Queue 'MACRO X$SUPD$X' fn ft workfm /* Set fileid and save */

                                 /* call XEDIT to do it      */
  'XEDIT' sourcefn '$'ft sourcefm  '(NOPROF NOMSG'
  realrc = rc
  If rc ¬= 0 Then do
     'DROPBUF'
     call ERRORS '100 671 fn ft fm realrc' msgopt1 'FORMAT 3'
     end

/* We need to determine if the updated macro is a REXX       */
/* program or not, as some option processing depends on the  */
/* type of program we're dealing with.                       */

  flag. = 0
  'EXECIO 1 DISKR' fn ft workfm '( FIND ?/*? STEM FLAG.'
  If flag.0 = 0 then rxflg = 0; else rxflg = 1
  rc = 0

/* First, are we supposed to remove marked comments?         */

  If ¬comments Then do           /* Remove all comments      */
     'XEDIT' fn ft workfm '(PROF X$EUPD$X NOMSG)' etmode rxflg
     realrc = rc
     If rc = 0 Then do
        'COPYFILE X$EUPD$X CMSUT1' workfm fn ft workfm '(REP'
        realrc = rc
        If rc ¬= 0 Then do       /* If error, issue message  */
           'DROPBUF'
           call ERRORS '40 653 ''COPYFILE'' realrc',
            msgopt1 'FORMAT 1'
           end

        'ERASE X$EUPD$X CMSUT1' workfm
        realrc = rc
        If rc ¬= 0 Then do       /* If error, issue message  */
           'DROPBUF'
           call ERRORS '40 653 ''ERASE'' realrc',
            msgopt1 'FORMAT 1'
           end

        rc = 0
        end
        Else Do
           'DROPBUF'
           call ERRORS '100 671 fn ft fm realrc' ,
            msgopt1 'FORMAT 3'
           end
     end
  Else
  If compress Then do
     Queue 'COMMAND SET ZONE' 1 3  /* Only search cols 1-3   */
     Queue 'COMMAND SET TABS 1 10' /* Set TABS for input     */
     Queue 'COMMAND INPUT /*!*/' /* Ensure at least one found*/
     Queue 'MACRO ALL ?/*!?'  /* Collect comments            */
     Queue 'COMMAND TOP'      /* Go to the top first         */
     Queue 'COMMAND DELETE *' /* Remove all the comments     */
     Queue 'COMMAND FILE'
     'XEDIT' fn ft workfm '( NOPROF NOMSG'
     realrc = rc
     end

  If rc ¬= 0 Then do
     'DROPBUF'
     call ERRORS '100 671 fn ft fm realrc' msgopt1 'FORMAT 3'
     end

/* Do we also want the UPDATE history?                       */

  If history & updtrc ¬=40 & ¬noupdate Then do
     /* At this point, we need to append the file fn         */
     /* UPDATES to the exec bracketed by comment delimiters  */
     /* ('/*' & '*/' for REXX programs or '*' for non-REXX   */
     /* programs)                                            */

     If rxflg = 1 then do        /* We're dealing with REXX  */
        Queue 'COMMAND BOTTOM'   /* Go to the bottom         */
        Queue 'COMMAND INPUT  '  /* Add a line for neatness  */
        Queue 'COMMAND INPUT /* UPDATES applied at' time(),
           'on' date()           /* Add the header           */
        Queue 'COMMAND GET' fn 'UPDATES' workfm
        Queue 'COMMAND INPUT */'
        End
     Else do                   /* We're dealing with non-REXX*/
        Queue 'COMMAND EXTRACT /SIZE/'  /* Size of fn UPDATES*/
        Queue 'COMMAND FILE'
        'XEDIT' fn 'UPDATES' workfm '( NOPROF NOMSG'
        Queue 'COMMAND BOTTOM'   /* Go to the bottom         */
        Queue 'COMMAND INPUT  '  /* Add a line for neatness  */
        Queue 'COMMAND INPUT * UPDATES applied at' time(),
           'on' date()           /* Add the header           */
        i = 1
        Do i = 1 to size.1       /* Loop through fn UPDATES  */
           Queue 'COMMAND GET' fn 'UPDATES' workfm i '1'
           Queue 'COMMAND CINSERT * '
           End
        End
     Queue 'COMMAND FILE'
     'XEDIT' fn ft workfm '( NOPROF NOMSG'
     realrc = rc
     end
  If rc ¬= 0 Then do
     'DROPBUF'
     call ERRORS '100 671 fn ft fm realrc' msgopt1 'FORMAT 3'
     end


  If sourcefn = '$'fn Then       /* Updates applied?         */
     'ERASE $'fn '$'ft workfm    /* Scrap the work file      */
     realrc = rc
     If rc ¬= 0 Then             /* If error, issue message  */
       If rc ¬= 28 Then do       /* File not found is ok.    */
        'DROPBUF'
        call ERRORS '40 653 ''ERASE'' realrc',
         msgopt1 'FORMAT 1'
        end

  'DROPBUF'
  Exit updtrc                    /* all done, exit           */

/* Routine to separate options in EXECUPDT options and       */
/* options to be passed on to UPDATE.  EXECUPDT options are  */
/* also processed here. If OUTMODE is specified, we need     */
/* the output file mode for both.                            */

OPTIONS:
  Do until opts = ''
     parse var opts option opts  /* pull off first word      */
     select
        When otmode Then do         /* OUTMODE specified?    */
         otfm = option              /* get fm for EXECUPDT   */
         updtopts = updtopts option /* pass it on to UPDATE  */
         otmode = 0                 /* reset OUTMODE flag    */
         end
        When option='CTL' Then do
           /* Ok, CTL is specified, now check to see if a    */
           /* proper CNTRL file name has been given as well. */

          parse var opts cfn opts
          If cfn = '' Then       /* Anything there?          */
             call ERRORS '24 637 8129',
              msgopt1 'FORMAT 03'
          noupdate = 0
          end
        When option='SID' Then trunc = 17
        When option='NOSID' Then trunc = 8
        When abbrev('COMPRESS',option,4) Then compress = 1
        When abbrev('NOCOMPRESS',option,6) Then compress = 0
        When abbrev('COMMENTS',option,4) Then comments = 1
        When abbrev('NOCOMMENTS',option,6) Then comments = 0
        When abbrev('HISTORY',option,4) Then history = 1
        When abbrev('NOHISTORY',option,6) Then history = 0
        When abbrev('NOUPDATE',option,4) Then noupdate = 1
        When abbrev('ETMODE',option,6) Then etmode = 1
        When abbrev('OUTMODE',option,7) Then do
         otmode = 1                  /* set OUTMODE flag     */
         updtopts = updtopts option  /* pass it on to UPDATE */
         end
        /* Ok, it's none of the EXECUPDT options, so we build*/
        /* a list of options to pass on to the UPDATE command*/
        Otherwise updtopts = updtopts option
        end   /* Select */
     end   /* Do until */

  /* Fall through when options are all exhausted and return  */
  return       /* Nothing left, then return to caller.       */

NOVALUE: /* Report undefined variable and exit */
Parse source . . fn ft fm .
Say "Undefined variable referenced on line" sigl "of" fn ft fm
Exit 99

ERRORS:
    Arg rcode number msgopt
      'XMITMSG' number msgopt
    Exit rcode
